// This file is auto-generated by GraphQL Code Generator.
// Do not edit manually. Run `pnpm codegen` to regenerate.

export const typeDefs = /* GraphQL */ `
schema {
  query: Query
  mutation: Mutation
}

type ATSBoard {
  board_type: ATSBoardType!
  company_id: Int!
  confidence: Float!
  created_at: String!
  evidence: Evidence!
  first_seen_at: String!
  id: Int!
  is_active: Boolean!
  last_seen_at: String!
  updated_at: String!
  url: String!
  vendor: ATSVendor!
}

enum ATSBoardType {
  BOARD_API
  BOARD_WIDGET
  JOBS_PAGE
  UNKNOWN
}

input ATSBoardUpsertInput {
  board_type: ATSBoardType!
  confidence: Float!
  evidence: EvidenceInput!
  is_active: Boolean!
  last_seen_at: String!
  url: String!
  vendor: ATSVendor!
}

enum ATSVendor {
  ASHBY
  BREEZYHR
  GREENHOUSE
  ICIMS
  JAZZHR
  JOBVITE
  LEVER
  ORACLE_TALEO
  OTHER
  SAP_SUCCESSFACTORS
  SMARTRECRUITERS
  TEAMTAILOR
  WORKABLE
}

type Application {
  companyName: String
  createdAt: String!
  email: EmailAddress!
  id: Int!
  jobId: String!
  jobTitle: String
  notes: String
  questions: [QuestionAnswer!]!
  resume: Upload
  status: ApplicationStatus!
}

input ApplicationInput {
  companyName: String
  jobId: String!
  jobTitle: String
  questions: [QuestionAnswerInput!]!
  resume: Upload
}

"""
Pipeline status for a tracked job application.
Maps to a kanban column in the UI.
"""
enum ApplicationStatus {
  accepted
  pending
  rejected
  reviewed
  submitted
}

type AshbyAddress {
  postalAddress: AshbyPostalAddress
}

type AshbyCompensation {
  compensationTierSummary: String
  compensationTiers: [AshbyCompensationTier!]!
  scrapeableCompensationSalarySummary: String
  summaryComponents: [AshbyCompensationComponent!]!
}

type AshbyCompensationComponent {
  compensationType: String
  currencyCode: String
  id: String
  interval: String
  maxValue: Float
  minValue: Float
  summary: String
}

type AshbyCompensationTier {
  additionalInformation: String
  components: [AshbyCompensationComponent!]!
  id: String
  tierSummary: String
  title: String
}

type AshbyEnrichment {
  company_name: String
  enriched_at: String
  industry_tags: [String!]!
  size_signal: String
  tech_signals: [String!]!
}

type AshbyPostalAddress {
  addressCountry: String
  addressLocality: String
  addressRegion: String
}

type AshbySecondaryLocation {
  address: AshbyPostalAddress
  location: String!
}

type ChatMessage {
  content: String!
  role: String!
}

input ChatMessageInput {
  content: String!
  role: String!
}

"""Confidence level of a classification result."""
enum ClassificationConfidence {
  high
  low
  medium
}

type CompaniesResponse {
  companies: [Company!]!
  totalCount: Int!
}

type Company {
  ashby_enrichment: AshbyEnrichment
  ats_boards: [ATSBoard!]!
  canonical_domain: String
  category: CompanyCategory!
  created_at: String!
  description: String
  facts(field: String, limit: Int, offset: Int): [CompanyFact!]!
  facts_count: Int!
  id: Int!
  industries: [String!]!
  industry: String
  key: String!
  last_seen_capture_timestamp: String
  last_seen_crawl_id: String
  last_seen_source_url: String
  location: String
  logo_url: String
  name: String!
  score: Float!
  score_reasons: [String!]!
  service_taxonomy: [String!]!
  services: [String!]!
  size: String
  snapshots(limit: Int, offset: Int): [CompanySnapshot!]!
  snapshots_count: Int!
  tags: [String!]!
  updated_at: String!
  website: String
}

enum CompanyCategory {
  AGENCY
  CONSULTANCY
  DIRECTORY
  OTHER
  PRODUCT
  STAFFING
  UNKNOWN
}

type CompanyFact {
  company_id: Int!
  confidence: Float!
  created_at: String!
  evidence: Evidence!
  field: String!
  id: Int!
  normalized_value: JSON
  value_json: JSON
  value_text: String
}

input CompanyFactInput {
  confidence: Float!
  evidence: EvidenceInput!
  field: String!
  normalized_value: JSON
  value_json: JSON
  value_text: String
}

input CompanyFilterInput {
  canonical_domain_in: [String!]
  category_in: [CompanyCategory!]
  has_ats_boards: Boolean
  min_score: Float
  service_taxonomy_any: [String!]
  text: String
}

enum CompanyOrderBy {
  CREATED_AT_DESC
  NAME_ASC
  SCORE_DESC
  UPDATED_AT_DESC
}

type CompanySnapshot {
  capture_timestamp: String
  company_id: Int!
  content_hash: String
  crawl_id: String
  created_at: String!
  evidence: Evidence!
  extracted: JSON
  fetched_at: String!
  http_status: Int
  id: Int!
  jsonld: JSON
  mime: String
  source_url: String!
  text_sample: String
}

input CreateCompanyInput {
  canonical_domain: String
  category: CompanyCategory
  description: String
  industries: [String!]
  industry: String
  key: String!
  location: String
  logo_url: String
  name: String!
  service_taxonomy: [String!]
  services: [String!]
  size: String
  tags: [String!]
  website: String
}

input CreateLangSmithPromptInput {
  description: String
  isPublic: Boolean
  readme: String
  tags: [String!]
}

input CreatePromptInput {
  chatMessages: [ChatMessageInput!]
  config: PromptConfigInput
  labels: [String!]
  name: String!
  prompt: String
  tags: [String!]
  type: PromptType!
}

input CreateTrackInput {
  description: String
  level: String
  slug: String!
  title: String!
}

scalar DateTime

type DeleteCompanyResponse {
  message: String
  success: Boolean!
}

type DeleteJobResponse {
  message: String
  success: Boolean!
}

scalar EmailAddress

type EnhanceCompanyResponse {
  companyId: Int
  companyKey: String
  message: String
  success: Boolean!
}

"""Response from enhancing a job with ATS data"""
type EnhanceJobResponse {
  """The updated job record with enhanced data from the ATS"""
  job: Job
  """Human-readable message about the operation result"""
  message: String
  """Whether the enhancement was successful"""
  success: Boolean!
}

type Evidence {
  capture_timestamp: String
  content_hash: String
  crawl_id: String
  extractor_version: String
  http_status: Int
  method: ExtractMethod!
  mime: String
  observed_at: String!
  source_type: SourceType!
  source_url: String!
  warc: WarcPointer
}

input EvidenceInput {
  capture_timestamp: String
  content_hash: String
  crawl_id: String
  extractor_version: String
  http_status: Int
  method: ExtractMethod!
  mime: String
  observed_at: String!
  source_type: SourceType!
  source_url: String!
  warc: WarcPointerInput
}

enum ExtractMethod {
  DOM
  HEURISTIC
  JSONLD
  LLM
  META
}

type GreenhouseCompliance {
  description: String
  questions: [GreenhouseQuestion!]
  type: String!
}

type GreenhouseDataCompliance {
  demographic_data_consent_applies: Boolean!
  requires_consent: Boolean!
  requires_processing_consent: Boolean!
  requires_retention_consent: Boolean!
  retention_period: Int
  type: String!
}

type GreenhouseDemographicQuestions {
  description: String
  header: String
  questions: [GreenhouseQuestion!]
}

type GreenhouseDepartment {
  child_ids: [String!]
  id: String!
  name: String!
  parent_id: String
}

type GreenhouseMetadata {
  id: String!
  name: String!
  value: String
  value_type: String
}

type GreenhouseOffice {
  child_ids: [String!]
  id: String!
  location: String
  name: String!
  parent_id: String
}

type GreenhouseQuestion {
  description: String
  fields: [GreenhouseQuestionField!]
  label: String!
  required: Boolean!
}

type GreenhouseQuestionField {
  name: String
  type: String!
}

scalar JSON

type Job {
  absolute_url: String
  ashby_address: AshbyAddress
  ashby_apply_url: String
  ashby_compensation: AshbyCompensation
  ashby_department: String
  ashby_employment_type: String
  ashby_is_listed: Boolean
  ashby_is_remote: Boolean
  ashby_job_url: String
  ashby_secondary_locations: [AshbySecondaryLocation!]
  ashby_team: String
  company: Company
  company_id: Int
  company_key: String!
  company_name: String
  compliance: [GreenhouseCompliance!]
  created_at: String!
  data_compliance: [GreenhouseDataCompliance!]
  demographic_questions: GreenhouseDemographicQuestions
  departments: [GreenhouseDepartment!]
  description: String
  external_id: String!
  id: Int!
  internal_job_id: String
  """
  Whether this job is classified as Remote EU — read directly from the DB column.
  """
  is_remote_eu: Boolean!
  language: String
  location: String
  location_questions: [GreenhouseQuestion!]
  metadata: [GreenhouseMetadata!]
  offices: [GreenhouseOffice!]
  """
  Canonical publication date. All ATS sources (Greenhouse, Ashby)
  write to the unified first_published DB column at ingestion time.
  Falls back to posted_at (ingestion timestamp) when no ATS date exists.
  """
  publishedAt: String!
  questions: [GreenhouseQuestion!]
  remote_eu_confidence: ClassificationConfidence
  remote_eu_reason: String
  requisition_id: String
  score: Float
  score_reason: String
  skillMatch: SkillMatch
  skills: [JobSkill!]
  source_id: String
  source_kind: String!
  status: JobStatus
  title: String!
  updated_at: String!
  url: String!
}

type JobSkill {
  confidence: Float
  evidence: String
  level: String!
  tag: String!
}

"""
Pipeline status for a job posting.
Mirrors workers/process-jobs/src/entry.py JobStatus enum — values must stay in sync.
"""
enum JobStatus {
  enhanced
  error
  eu_remote
  new
  non_eu
  reported
  role_match
  role_nomatch
}

type JobsResponse {
  jobs: [Job!]!
  totalCount: Int!
}

type LangSmithPrompt {
  createdAt: String!
  description: String
  fullName: String!
  id: String!
  isArchived: Boolean!
  isPublic: Boolean!
  lastCommitHash: String
  likedByAuthUser: Boolean!
  numCommits: Int!
  numDownloads: Int!
  numLikes: Int!
  numViews: Int!
  owner: String
  promptHandle: String!
  readme: String
  tags: [String!]!
  tenantId: String!
  updatedAt: String!
}

type LangSmithPromptCommit {
  commitHash: String!
  examples: [JSON!]!
  manifest: JSON!
  owner: String!
  promptName: String!
}

type Mutation {
  add_company_facts(company_id: Int!, facts: [CompanyFactInput!]!): [CompanyFact!]!
  createApplication(input: ApplicationInput!): Application!
  createCompany(input: CreateCompanyInput!): Company!
  createLangSmithPrompt(input: CreateLangSmithPromptInput, promptIdentifier: String!): LangSmithPrompt!
  createPrompt(input: CreatePromptInput!): Prompt!
  createTrack(input: CreateTrackInput!): Track!
  deleteAllJobs: DeleteJobResponse!
  deleteCompany(id: Int!): DeleteCompanyResponse!
  deleteJob(id: Int!): DeleteJobResponse!
  deleteLangSmithPrompt(promptIdentifier: String!): Boolean!
  enhanceCompany(id: Int, key: String): EnhanceCompanyResponse!
  """
  Enhance a job posting by fetching detailed data from the ATS (Applicant Tracking System).
  
  Supported ATS sources:
  - greenhouse: Greenhouse ATS (https://greenhouse.io)
  - ashby: Ashby ATS (https://ashbyhq.com)
  
  For Greenhouse:
  - jobId: The job posting ID from the URL (e.g., "5802159004" from https://job-boards.greenhouse.io/grafanalabs/jobs/5802159004)
  - company: The board token (e.g., "grafanalabs")
  
  For Ashby:
  - jobId: The posting ID
  - company: The board name
  
  The mutation will:
  1. Fetch comprehensive job data from the ATS API
  2. Save enhanced fields (description, departments, offices, questions, etc.)
  3. Return the updated job with full ATS data
  """
  enhanceJobFromATS(company: String!, jobId: String!, source: String!): EnhanceJobResponse!
  generateResearch(goalDescription: String!): [ResearchItem!]!
  ingestResumeParse(email: String!, filename: String!, job_id: String!): ResumeIngestResult
  ingest_company_snapshot(capture_timestamp: String, company_id: Int!, content_hash: String, crawl_id: String, evidence: EvidenceInput!, extracted: JSON, fetched_at: String!, http_status: Int, jsonld: JSON, mime: String, source_url: String!, text_sample: String): CompanySnapshot!
  """
  Trigger classification/enhancement of all unprocessed jobs via the Cloudflare Worker.
  Calls the classify-jobs CF worker (POST) which runs DeepSeek-based classification
  for remote-EU eligibility on every unclassified job.
  """
  processAllJobs(limit: Int): ProcessAllJobsResponse!
  pushLangSmithPrompt(input: PushLangSmithPromptInput, promptIdentifier: String!): String!
  """
  Report a job as irrelevant, spam, or incorrectly classified.
  Sets the job status to "reported" so it can be reviewed or excluded.
  Requires authentication.
  """
  reportJob(id: Int!): Job
  updateApplication(id: Int!, input: UpdateApplicationInput!): Application!
  updateCompany(id: Int!, input: UpdateCompanyInput!): Company!
  updateLangSmithPrompt(input: UpdateLangSmithPromptInput!, promptIdentifier: String!): LangSmithPrompt!
  updatePromptLabel(label: String!, name: String!, version: Int!): Prompt!
  updateUserSettings(settings: UserSettingsInput!, userId: String!): UserSettings!
  uploadResume(email: String!, filename: String!, resumePdf: String!): ResumeUploadResult
  upsert_company_ats_boards(boards: [ATSBoardUpsertInput!]!, company_id: Int!): [ATSBoard!]!
}

type PrepCategory {
  description: String!
  emoji: String!
  id: String!
  name: String!
  resources: [PrepResource!]!
}

type PrepContent {
  categories: [PrepCategory!]!
  totalResources: Int!
}

type PrepResource {
  category: String!
  description: String!
  href: URL!
  id: String!
  tags: [String!]!
  title: String!
}

"""Response from triggering the classify-jobs Cloudflare Worker"""
type ProcessAllJobsResponse {
  """Number of errors during ATS enhancement"""
  enhanceErrors: Int
  """Number of jobs enhanced with ATS data in this run"""
  enhanced: Int
  """Number of errors encountered during classification"""
  errors: Int
  """Number of jobs classified as EU-remote"""
  euRemote: Int
  message: String
  """Number of jobs classified as non-EU"""
  nonEuRemote: Int
  """Number of jobs classified in this run"""
  processed: Int
  success: Boolean!
}

type Prompt {
  chatMessages: [ChatMessage!]
  config: PromptConfig
  createdAt: String
  createdBy: String
  isUserSpecific: Boolean!
  labels: [String!]
  name: String!
  prompt: String
  tags: [String!]
  type: PromptType!
  updatedAt: String
  version: Int
}

type PromptConfig {
  max_tokens: Int
  model: String
  temperature: Float
  top_p: Float
}

input PromptConfigInput {
  max_tokens: Int
  model: String
  temperature: Float
  top_p: Float
}

enum PromptType {
  CHAT
  TEXT
}

type PromptUsage {
  label: String
  promptName: String!
  traceId: String
  usedAt: String!
  userEmail: String!
  version: Int
}

input PushLangSmithPromptInput {
  description: String
  isPublic: Boolean
  object: JSON
  parentCommitHash: String
  readme: String
  tags: [String!]
}

type Query {
  applications: [Application!]!
  askAboutResume(email: String!, question: String!): ResumeAnswer
  companies(filter: CompanyFilterInput, limit: Int, offset: Int, order_by: CompanyOrderBy): CompaniesResponse!
  company(id: Int, key: String): Company
  company_ats_boards(company_id: Int!): [ATSBoard!]!
  company_facts(company_id: Int!, field: String, limit: Int, offset: Int): [CompanyFact!]!
  company_snapshots(company_id: Int!, limit: Int, offset: Int): [CompanySnapshot!]!
  executeSql(sql: String!): TextToSqlResult!
  job(id: String!): Job
  jobs(excludedCompanies: [String!], isRemoteEu: Boolean, limit: Int, offset: Int, remoteEuConfidence: String, search: String, skills: [String!], sourceType: String): JobsResponse!
  langsmithPrompt(promptIdentifier: String!): LangSmithPrompt
  langsmithPromptCommit(includeModel: Boolean, promptIdentifier: String!): LangSmithPromptCommit
  langsmithPrompts(isArchived: Boolean, isPublic: Boolean, query: String): [LangSmithPrompt!]!
  myPromptUsage(limit: Int): [PromptUsage!]!
  prepResources: PrepContent!
  prepResourcesByCategory(category: String!): [PrepResource!]!
  prompt(label: String, name: String!, version: Int): Prompt
  prompts: [RegisteredPrompt!]!
  resumeStatus(email: String!): ResumeStatus
  textToSql(question: String!): TextToSqlResult!
  track(slug: String!): Track
  tracks(limit: Int = 50): [Track!]!
  userSettings(userId: String!): UserSettings
}

type QuestionAnswer {
  answerText: String!
  questionId: String!
  questionText: String!
}

input QuestionAnswerInput {
  answerText: String!
  questionId: String!
  questionText: String!
}

type RegisteredPrompt {
  content: JSON
  labels: [String!]!
  lastConfig: JSON
  lastUpdatedAt: String!
  lastUsedBy: String
  name: String!
  tags: [String!]!
  type: String!
  usageCount: Int
  versions: [Int!]!
}

type ResearchItem {
  id: String!
  relevance: String
  summary: String!
  title: String!
  url: URL!
}

type ResumeAnswer {
  answer: String!
  context_count: Int!
}

type ResumeIngestResult {
  chunks_stored: Int
  error: String
  job_id: String!
  resume_id: String
  status: String!
  success: Boolean!
}

type ResumeStatus {
  chunk_count: Int
  exists: Boolean!
  filename: String
  ingested_at: String
  resume_id: String
}

type ResumeUploadResult {
  job_id: String!
  status: String!
  success: Boolean!
  tier: String!
}

type SkillMatch {
  details: [SkillMatchDetail!]!
  jobCoverage: Float!
  matchedCount: Int!
  requiredCoverage: Float!
  score: Float!
  totalPreferred: Int!
  userCoverage: Float!
}

type SkillMatchDetail {
  level: String!
  matched: Boolean!
  tag: String!
}

enum SourceType {
  COMMONCRAWL
  LIVE_FETCH
  MANUAL
  PARTNER
}

type TextToSqlResult {
  columns: [String!]!
  drilldownSearchQuery: String
  explanation: String
  rows: [[JSON]]!
  sql: String!
}

type Track {
  description: String
  id: ID!
  items: [TrackItem!]!
  level: String
  slug: String!
  title: String!
}

type TrackItem {
  children: [TrackItem!]!
  contentRef: String
  difficulty: Int
  id: ID!
  kind: String!
  position: Int!
  prereqs: [ID!]!
  promptRef: String
  tags: [String!]!
  title: String!
}

scalar URL

input UpdateApplicationInput {
  notes: String
  status: ApplicationStatus
}

input UpdateCompanyInput {
  canonical_domain: String
  category: CompanyCategory
  description: String
  industries: [String!]
  industry: String
  key: String
  location: String
  logo_url: String
  name: String
  score: Float
  score_reasons: [String!]
  service_taxonomy: [String!]
  services: [String!]
  size: String
  tags: [String!]
  website: String
}

input UpdateLangSmithPromptInput {
  description: String
  isArchived: Boolean
  isPublic: Boolean
  readme: String
  tags: [String!]
}

scalar Upload

type UserSettings {
  created_at: String!
  daily_digest: Boolean!
  dark_mode: Boolean!
  email_notifications: Boolean!
  excluded_companies: [String!]
  id: Int!
  jobs_per_page: Int!
  new_job_alerts: Boolean!
  preferred_locations: [String!]
  preferred_skills: [String!]
  updated_at: String!
  user_id: String!
}

input UserSettingsInput {
  daily_digest: Boolean
  dark_mode: Boolean
  email_notifications: Boolean
  excluded_companies: [String!]
  jobs_per_page: Int
  new_job_alerts: Boolean
  preferred_locations: [String!]
  preferred_skills: [String!]
}

type WarcPointer {
  digest: String
  filename: String!
  length: Int!
  offset: Int!
}

input WarcPointerInput {
  digest: String
  filename: String!
  length: Int!
  offset: Int!
}
`;