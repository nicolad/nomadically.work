import { sqliteTable, AnySQLiteColumn, index, integer, text, foreignKey, real, uniqueIndex, numeric, blob } from "drizzle-orm/sqlite-core"
  import { sql } from "drizzle-orm"

export const jobSources = sqliteTable("job_sources", {
	id: integer().primaryKey({ autoIncrement: true }),
	kind: text().notNull(),
	companyKey: text("company_key").notNull(),
	canonicalUrl: text("canonical_url"),
	firstSeenAt: text("first_seen_at").notNull(),
	lastFetchedAt: text("last_fetched_at"),
	createdAt: text("created_at").default("sql`(CURRENT_TIMESTAMP)`"),
},
(table) => [
	index("idx_job_sources_kind").on(table.kind),
]);

export const jobs = sqliteTable("jobs", {
	id: integer().primaryKey({ autoIncrement: true }),
	externalId: text("external_id").notNull(),
	sourceId: integer("source_id").references(() => jobSources.id),
	sourceKind: text("source_kind").notNull(),
	companyKey: text("company_key").notNull(),
	title: text().notNull(),
	location: text(),
	url: text().notNull(),
	description: text(),
	postedAt: text("posted_at"),
	score: real(),
	scoreReason: text("score_reason"),
	status: text().default("new"),
	createdAt: text("created_at").default("sql`(CURRENT_TIMESTAMP)`"),
	updatedAt: text("updated_at").default("sql`(CURRENT_TIMESTAMP)`"),
	isRemoteEu: integer("is_remote_eu"),
	remoteEuConfidence: text("remote_eu_confidence"),
	remoteEuReason: text("remote_eu_reason"),
	remoteEuClassifiedAt: text("remote_eu_classified_at"),
	companyId: integer("company_id").references(() => companies.id, { onDelete: "cascade" } ),
	atsData: text("ats_data"),
	ghInternalJobId: integer("gh_internal_job_id"),
	ghRequisitionId: text("gh_requisition_id"),
	ghDepartments: text("gh_departments"),
	ghOffices: text("gh_offices"),
	ghQuestions: text("gh_questions"),
	ghLocationQuestions: text("gh_location_questions"),
	ghCompliance: text("gh_compliance"),
	ghDemographicQuestions: text("gh_demographic_questions"),
	internalJobId: integer("internal_job_id"),
	requisitionId: text("requisition_id"),
	departments: text(),
	offices: text(),
	questions: text(),
	locationQuestions: text("location_questions"),
	compliance: text(),
	demographicQuestions: text("demographic_questions"),
	absoluteUrl: text("absolute_url"),
	companyName: text("company_name"),
	firstPublished: text("first_published"),
	language: text(),
	metadata: text(),
	dataCompliance: text("data_compliance"),
	categories: text(),
	workplaceType: text("workplace_type"),
	country: text(),
	opening: text(),
	openingPlain: text("opening_plain"),
	descriptionBody: text("description_body"),
	descriptionBodyPlain: text("description_body_plain"),
	additional: text(),
	additionalPlain: text("additional_plain"),
	lists: text(),
	atsCreatedAt: text("ats_created_at"),
},
(table) => [
	index("idx_jobs_requisition_id").on(table.requisitionId),
	index("idx_jobs_internal_job_id").on(table.internalJobId),
	index("idx_jobs_gh_requisition_id").on(table.ghRequisitionId),
	index("idx_jobs_gh_internal_job_id").on(table.ghInternalJobId),
	index("idx_jobs_company_id").on(table.companyId),
	index("idx_jobs_posted_at").on(table.postedAt),
	index("idx_jobs_score").on(table.score),
	index("idx_jobs_status").on(table.status),
]);

export const ashbyBoards = sqliteTable("ashby_boards", {
	id: integer().primaryKey({ autoIncrement: true }).notNull(),
	boardName: text("board_name").notNull(),
	discoveredAt: text("discovered_at").default("sql`(datetime('now'))`").notNull(),
	lastSyncedAt: text("last_synced_at"),
	jobCount: integer("job_count").default(0),
	isActive: integer("is_active").default(1).notNull(),
	createdAt: text("created_at").default("sql`(datetime('now'))`").notNull(),
	updatedAt: text("updated_at").default("sql`(datetime('now'))`").notNull(),
},
(table) => [
	uniqueIndex("ashby_boards_board_name_unique").on(table.boardName),
]);

export const userSettings = sqliteTable("user_settings", {
	id: integer().primaryKey({ autoIncrement: true }).notNull(),
	userId: text("user_id").notNull(),
	emailNotifications: integer("email_notifications").default(1).notNull(),
	dailyDigest: integer("daily_digest").default(0).notNull(),
	newJobAlerts: integer("new_job_alerts").default(1).notNull(),
	preferredLocations: text("preferred_locations"),
	preferredSkills: text("preferred_skills"),
	excludedCompanies: text("excluded_companies"),
	darkMode: integer("dark_mode").default(1).notNull(),
	jobsPerPage: integer("jobs_per_page").default(20).notNull(),
	createdAt: text("created_at").default("sql`(datetime('now'))`").notNull(),
	updatedAt: text("updated_at").default("sql`(datetime('now'))`").notNull(),
});

export const jobSkillTags = sqliteTable("job_skill_tags", {
	jobId: integer("job_id").notNull().references(() => jobs.id, { onDelete: "cascade" } ),
	tag: text().notNull(),
	level: text().notNull(),
	confidence: real(),
	evidence: text(),
	extractedAt: text("extracted_at").notNull(),
	version: text().notNull(),
});

export const skillAliases = sqliteTable("skill_aliases", {
	alias: text().primaryKey().notNull(),
	tag: text().notNull(),
});

export const mastraScorers = sqliteTable("mastra_scorers", {
	id: text().primaryKey().notNull(),
	scorerId: text(),
	traceId: text(),
	spanId: text(),
	runId: text(),
	scorer: text(),
	preprocessStepResult: text(),
	extractStepResult: text(),
	analyzeStepResult: text(),
	score: real(),
	reason: text(),
	metadata: text(),
	preprocessPrompt: text(),
	extractPrompt: text(),
	generateScorePrompt: text(),
	generateReasonPrompt: text(),
	analyzePrompt: text(),
	reasonPrompt: text(),
	input: text(),
	output: text(),
	additionalContext: text(),
	requestContext: text(),
	entityType: text(),
	entity: text(),
	entityId: text(),
	source: text(),
	resourceId: text(),
	threadId: text(),
	createdAt: text(),
	updatedAt: text(),
});

export const skillsTaxonomy = sqliteTable("skills_taxonomy", {
	id: numeric().primaryKey(),
	vectorId: text("vector_id").notNull(),
	embedding: numeric(),
	metadata: text().default("{}"),
},
(table) => [
	index("skills_taxonomy_vector_idx").on(),
]);

export const mastraThreads = sqliteTable("mastra_threads", {
	id: text().primaryKey().notNull(),
	resourceId: text().notNull(),
	title: text().notNull(),
	metadata: text(),
	createdAt: text().notNull(),
	updatedAt: text().notNull(),
});

export const skillsTaxonomyVectorIdxShadow = sqliteTable("skills_taxonomy_vector_idx_shadow", {
	indexKey: integer("index_key").primaryKey(),
	data: blob(),
},
(table) => [
	index("skills_taxonomy_vector_idx_shadow_idx").on(table.indexKey),
]);

export const mastraMessages = sqliteTable("mastra_messages", {
	id: text().primaryKey().notNull(),
	threadId: text("thread_id").notNull(),
	content: text().notNull(),
	role: text().notNull(),
	type: text().notNull(),
	createdAt: text().notNull(),
	resourceId: text(),
});

export const mastraResources = sqliteTable("mastra_resources", {
	id: text().primaryKey().notNull(),
	workingMemory: text(),
	metadata: text(),
	createdAt: text().notNull(),
	updatedAt: text().notNull(),
});

export const mastraObservationalMemory = sqliteTable("mastra_observational_memory", {
	id: text().primaryKey().notNull(),
	lookupKey: text().notNull(),
	scope: text().notNull(),
	resourceId: text(),
	threadId: text(),
	activeObservations: text().notNull(),
	activeObservationsPendingUpdate: text(),
	originType: text().notNull(),
	config: text().notNull(),
	generationCount: integer().notNull(),
	lastObservedAt: text(),
	lastReflectionAt: text(),
	pendingMessageTokens: integer().notNull(),
	totalTokensObserved: integer().notNull(),
	observationTokenCount: integer().notNull(),
	isObserving: integer().notNull(),
	isReflecting: integer().notNull(),
	observedMessageIds: text(),
	observedTimezone: text(),
	createdAt: text().notNull(),
	updatedAt: text().notNull(),
},
(table) => [
	index("idx_om_lookup_key").on(table.lookupKey),
]);

export const mastraAiSpans = sqliteTable("mastra_ai_spans", {
	traceId: text().notNull(),
	spanId: text().notNull(),
	name: text().notNull(),
	spanType: text().notNull(),
	isEvent: integer().notNull(),
	startedAt: text().notNull(),
	parentSpanId: text(),
	entityType: text(),
	entityId: text(),
	entityName: text(),
	userId: text(),
	organizationId: text(),
	resourceId: text(),
	runId: text(),
	sessionId: text(),
	threadId: text(),
	requestId: text(),
	environment: text(),
	source: text(),
	serviceName: text(),
	scope: text(),
	metadata: text(),
	tags: text(),
	attributes: text(),
	links: text(),
	input: text(),
	output: text(),
	error: text(),
	endedAt: text(),
	createdAt: text().notNull(),
	updatedAt: text(),
},
(table) => [
	uniqueIndex("mastra_ai_spans_spanid_traceid_idx").on(table.spanId, table.traceId),
]);

export const mastraWorkflowSnapshot = sqliteTable("mastra_workflow_snapshot", {
	workflowName: text("workflow_name"),
	runId: text("run_id"),
	resourceId: text(),
	snapshot: text(),
	createdAt: text(),
	updatedAt: text(),
});

export const companies = sqliteTable("companies", {
	id: integer().primaryKey({ autoIncrement: true }),
	key: text().notNull(),
	name: text().notNull(),
	logoUrl: text("logo_url"),
	website: text(),
	description: text(),
	industry: text(),
	size: text(),
	location: text(),
	createdAt: text("created_at").default("sql`(datetime('now'))`").notNull(),
	updatedAt: text("updated_at").default("sql`(datetime('now'))`").notNull(),
	canonicalDomain: text("canonical_domain"),
	category: text().default("UNKNOWN").notNull(),
	tags: text(),
	services: text(),
	serviceTaxonomy: text("service_taxonomy"),
	industries: text(),
	score: real().default(0.5).notNull(),
	scoreReasons: text("score_reasons"),
	lastSeenCrawlId: text("last_seen_crawl_id"),
	lastSeenCaptureTimestamp: text("last_seen_capture_timestamp"),
	lastSeenSourceUrl: text("last_seen_source_url"),
},
(table) => [
	index("idx_companies_key").on(table.key),
]);

export const companyFacts = sqliteTable("company_facts", {
	id: integer().primaryKey({ autoIncrement: true }),
	companyId: integer("company_id").notNull().references(() => companies.id, { onDelete: "cascade" } ),
	field: text().notNull(),
	valueJson: text("value_json"),
	valueText: text("value_text"),
	normalizedValue: text("normalized_value"),
	confidence: real().notNull(),
	sourceType: text("source_type").notNull(),
	sourceUrl: text("source_url").notNull(),
	crawlId: text("crawl_id"),
	captureTimestamp: text("capture_timestamp"),
	observedAt: text("observed_at").notNull(),
	method: text().notNull(),
	extractorVersion: text("extractor_version"),
	httpStatus: integer("http_status"),
	mime: text(),
	contentHash: text("content_hash"),
	warcFilename: text("warc_filename"),
	warcOffset: integer("warc_offset"),
	warcLength: integer("warc_length"),
	warcDigest: text("warc_digest"),
	createdAt: text("created_at").default("sql`(datetime('now'))`").notNull(),
},
(table) => [
	index("idx_company_facts_company_field").on(table.companyId, table.field),
]);

export const companySnapshots = sqliteTable("company_snapshots", {
	id: integer().primaryKey({ autoIncrement: true }),
	companyId: integer("company_id").notNull().references(() => companies.id, { onDelete: "cascade" } ),
	sourceUrl: text("source_url").notNull(),
	crawlId: text("crawl_id"),
	captureTimestamp: text("capture_timestamp"),
	fetchedAt: text("fetched_at").notNull(),
	httpStatus: integer("http_status"),
	mime: text(),
	contentHash: text("content_hash"),
	textSample: text("text_sample"),
	jsonld: text(),
	extracted: text(),
	sourceType: text("source_type").notNull(),
	method: text().notNull(),
	extractorVersion: text("extractor_version"),
	warcFilename: text("warc_filename"),
	warcOffset: integer("warc_offset"),
	warcLength: integer("warc_length"),
	warcDigest: text("warc_digest"),
	createdAt: text("created_at").default("sql`(datetime('now'))`").notNull(),
},
(table) => [
	index("idx_company_snapshots_company_hash").on(table.companyId, table.contentHash),
]);

export const atsBoards = sqliteTable("ats_boards", {
	id: integer().primaryKey({ autoIncrement: true }),
	companyId: integer("company_id").notNull().references(() => companies.id, { onDelete: "cascade" } ),
	url: text().notNull(),
	vendor: text().notNull(),
	boardType: text("board_type").notNull(),
	confidence: real().notNull(),
	isActive: integer("is_active").default(1).notNull(),
	firstSeenAt: text("first_seen_at").notNull(),
	lastSeenAt: text("last_seen_at").notNull(),
	sourceType: text("source_type").notNull(),
	sourceUrl: text("source_url").notNull(),
	crawlId: text("crawl_id"),
	captureTimestamp: text("capture_timestamp"),
	observedAt: text("observed_at").notNull(),
	method: text().notNull(),
	extractorVersion: text("extractor_version"),
	warcFilename: text("warc_filename"),
	warcOffset: integer("warc_offset"),
	warcLength: integer("warc_length"),
	warcDigest: text("warc_digest"),
	createdAt: text("created_at").default("sql`(datetime('now'))`").notNull(),
	updatedAt: text("updated_at").default("sql`(datetime('now'))`").notNull(),
},
(table) => [
	index("idx_ats_boards_vendor").on(table.vendor),
	index("idx_ats_boards_company_url").on(table.companyId, table.url),
]);

export const applications = sqliteTable("applications", {
	id: integer().primaryKey({ autoIncrement: true }).notNull(),
	userEmail: text("user_email").notNull(),
	jobId: text("job_id").notNull(),
	resumeUrl: text("resume_url"),
	questions: text(),
	status: text().default("pending").notNull(),
	createdAt: text("created_at").default("sql`(datetime('now'))`").notNull(),
	updatedAt: text("updated_at").default("sql`(datetime('now'))`").notNull(),
});

